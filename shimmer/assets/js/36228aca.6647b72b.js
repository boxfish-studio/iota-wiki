"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[56084],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,f=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(f,s(s({ref:t},m),{},{components:n})):a.createElement(f,s({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},94731:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),o=n(34259),s=n(18679);const i={keywords:["balances","color","smart contract function","address","members","incoming","tokens","incoming"],description:"There are two methods in the ISC function context that deal with token balances. The balances() method can be used to determine the current total balance per token color. The incoming() method can be used to determine the amounts of incoming tokens per token color that were sent with the request to call the smart contract function.",image:"/img/logo/WASP_logo_dark.png"},l="Token Transfers",c={unversionedId:"guide/wasm_vm/transfers",id:"guide/wasm_vm/transfers",title:"Token Transfers",description:"There are two methods in the ISC function context that deal with token balances. The balances() method can be used to determine the current total balance per token color. The incoming() method can be used to determine the amounts of incoming tokens per token color that were sent with the request to call the smart contract function.",source:"@site/shimmer/external/wasp/documentation/docs/guide/wasm_vm/transfers.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/transfers",permalink:"/shimmer/smart-contracts/guide/wasm_vm/transfers",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/master/documentation/shimmer/external/wasp/documentation/docs/guide/wasm_vm/transfers.mdx",tags:[],version:"current",frontMatter:{keywords:["balances","color","smart contract function","address","members","incoming","tokens","incoming"],description:"There are two methods in the ISC function context that deal with token balances. The balances() method can be used to determine the current total balance per token color. The incoming() method can be used to determine the amounts of incoming tokens per token color that were sent with the request to call the smart contract function.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Smart Contract Initialization",permalink:"/shimmer/smart-contracts/guide/wasm_vm/init"},next:{title:"Function Descriptors",permalink:"/shimmer/smart-contracts/guide/wasm_vm/funcdesc"}},m={},d=[],u={toc:d};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"token-transfers"},"Token Transfers"),(0,r.kt)("p",null,"There are two methods in the ISC function context that deal with token balances. The first\none is the ",(0,r.kt)("inlineCode",{parentName:"p"},"balances()")," method, which can be used to determine the current asset balances\nthat are governed by the smart contract. The second one is the ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance()")," method, which\ncan be used to determine the caller assets that can be use by the current call to the\nsmart contract function."),(0,r.kt)("p",null,"Both methods provide access to zero or more balances of assets, through a special\n",(0,r.kt)("inlineCode",{parentName:"p"},"ScBalances")," proxy. Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance()")," balances are not automatically transferred\nto the smart contract but instead will need to explicitly transferred by the function.\nThat way, if a function cannot handle the transfer the tokens will stay safely in the\ncaller's on-chain account. The function explicitly transfers only assets it understands,\nand only in the amount that its algorithm defines, and never more than the allowed amount."),(0,r.kt)("p",null,"There is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer_allowed()")," method in the ISC function context that can transfer\nassets from the caller's on-chain account to any other on-chain account. The assets to be\ntransferred are provided to the method through a special ",(0,r.kt)("inlineCode",{parentName:"p"},"ScTransfer")," proxy, which is\nessentially a mutable version of ",(0,r.kt)("inlineCode",{parentName:"p"},"ScBalances"),". We will be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer_allowed()"),"\nmethod in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend")," example to disperse the incoming iotas to the member accounts."),(0,r.kt)("p",null,"The idea behind the dividend smart contract is that once we have set up the list of\nmembers, consisting of address/factor pairs, and knowing the total sum of the factors, we\ncan automatically pay out a dividend to each of the members in the list according to the\nfactors involved. Whatever amount of iotas gets sent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide()")," function will be\ndivided over the members in proportion based on their respective factors. For example, you\ncould set it up so that address A has a factor of 50, B has 30, and C has 20, for a total\nof 100 to divide. Then whenever an amount of iotas gets sent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide()")," function,\naddress A will receive 50/100th, address B will receive 30/100th, and address C will\nreceive 20/100th of that amount."),(0,r.kt)("p",null,"Here is the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// 'divide' is a function that will take any iotas it receives and properly\n// disperse them to the accounts in the member list according to the dispersion\n// factors associated with these accounts.\n// Anyone can send iotas to this function and they will automatically be\n// divided over the member list. Note that this function does not deal with\n// fractions. It simply truncates the calculated amount to the nearest lower\n// integer and keeps any remaining tokens in the sender account.\nfunc funcDivide(ctx wasmlib.ScFuncContext, f *DivideContext) {\n    // Create an ScBalances proxy to the allowance balances for this\n    // smart contract.\n    var allowance *wasmlib.ScBalances = ctx.Allowance()\n\n    // Retrieve the amount of plain iota tokens from the account balance.\n    var amount uint64 = allowance.BaseTokens()\n\n    // Retrieve the pre-calculated totalFactor value from the state storage.\n    var totalFactor uint64 = f.State.TotalFactor().Value()\n\n    // Get the proxy to the 'members' map in the state storage.\n    var members MapAddressToMutableUint64 = f.State.Members()\n\n    // Get the proxy to the 'memberList' array in the state storage.\n    var memberList ArrayOfMutableAddress = f.State.MemberList()\n\n    // Determine the current length of the memberList array.\n    var size uint32 = memberList.Length()\n\n    // Loop through all indexes of the memberList array.\n    for i := uint32(0); i < size; i++ {\n        // Retrieve the next indexed address from the memberList array.\n        var address wasmtypes.ScAddress = memberList.GetAddress(i).Value()\n\n        // Retrieve the factor associated with the address from the members map.\n        var factor uint64 = members.GetUint64(address).Value()\n\n        // Calculate the fair share of tokens to disperse to this member based on the\n        // factor we just retrieved. Note that the result will been truncated.\n        var share uint64 = amount * factor / totalFactor\n\n        // Is there anything to disperse to this member?\n        if share > 0 {\n            // Yes, so let's set up an ScTransfer map proxy that transfers the\n            // calculated amount of tokens.\n            var transfer *wasmlib.ScTransfer = wasmlib.NewScTransferBaseTokens(share)\n\n            // Perform the actual transfer of tokens from the caller allowance\n            // to the member account.\n            ctx.TransferAllowed(address.AsAgentID(), transfer, true)\n        }\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// 'divide' is a function that will take any iotas it receives and properly\n// disperse them to the accounts in the member list according to the dispersion\n// factors associated with these accounts.\n// Anyone can send iotas to this function and they will automatically be\n// divided over the member list. Note that this function does not deal with\n// fractions. It simply truncates the calculated amount to the nearest lower\n// integer and keeps any remaining tokens in its own account. They will be added\n// to any next round of tokens received prior to calculation of the new\n// dividend amounts.\npub fn func_divide(ctx: &ScFuncContext, f: &DivideContext) {\n\n    // Create an ScBalances proxy to the allowance balances for this\n    // smart contract.\n    let allowance: ScBalances = ctx.allowance();\n\n    // Retrieve the amount of plain iota tokens from the account balance.\n    let amount: u64 = allowance.base_tokens();\n\n    // Retrieve the pre-calculated totalFactor value from the state storage.\n    let total_factor: u64 = f.state.total_factor().value();\n\n    // Get the proxy to the 'members' map in the state storage.\n    let members: MapAddressToMutableUint64 = f.state.members();\n\n    // Get the proxy to the 'memberList' array in the state storage.\n    let member_list: ArrayOfMutableAddress = f.state.member_list();\n\n    // Determine the current length of the memberList array.\n    let size: u32 = member_list.length();\n\n    // Loop through all indexes of the memberList array.\n    for i in 0..size {\n        // Retrieve the next indexed address from the memberList array.\n        let address: ScAddress = member_list.get_address(i).value();\n\n        // Retrieve the factor associated with the address from the members map.\n        let factor: u64 = members.get_uint64(&address).value();\n\n        // Calculate the fair share of tokens to disperse to this member based on the\n        // factor we just retrieved. Note that the result will be truncated.\n        let share: u64 = amount * factor / total_factor;\n\n        // Is there anything to disperse to this member?\n        if share > 0 {\n            // Yes, so let's set up an ScTransfer map proxy that transfers the\n            // calculated amount of tokens.\n            let transfers: ScTransfer = ScTransfer::base_tokens(share);\n\n            // Perform the actual transfer of tokens from the caller allowance\n            // to the member account.\n            ctx.transfer_allowed(&address.as_agent_id(), &transfers, true);\n        }\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// 'divide' is a function that will take any iotas it receives and properly\n// disperse them to the accounts in the member list according to the dispersion\n// factors associated with these accounts.\n// Anyone can send iotas to this function and they will automatically be\n// divided over the member list. Note that this function does not deal with\n// fractions. It simply truncates the calculated amount to the nearest lower\n// integer and keeps any remaining tokens in its own account. They will be added\n// to any next round of tokens received prior to calculation of the new\n// dividend amounts.\nexport function funcDivide(ctx: wasmlib.ScFuncContext, f: sc.DivideContext): void {\n\n    // Create an ScBalances proxy to the allowance balances for this\n    // smart contract.\n    let allowance: wasmlib.ScBalances = ctx.allowance();\n\n    // Retrieve the allowed amount of plain iota tokens from the account balance.\n    let amount: u64 = allowance.baseTokens();\n\n    // Retrieve the pre-calculated totalFactor value from the state storage.\n    let totalFactor: u64 = f.state.totalFactor().value();\n\n    // Get the proxy to the 'members' map in the state storage.\n    let members: sc.MapAddressToMutableUint64 = f.state.members();\n\n    // Get the proxy to the 'memberList' array in the state storage.\n    let memberList: sc.ArrayOfMutableAddress = f.state.memberList();\n\n    // Determine the current length of the memberList array.\n    let size: u32 = memberList.length();\n\n    // Loop through all indexes of the memberList array.\n    for (let i: u32 = 0; i < size; i++) {\n        // Retrieve the next indexed address from the memberList array.\n        let address: wasmlib.ScAddress = memberList.getAddress(i).value();\n\n        // Retrieve the factor associated with the address from the members map.\n        let factor: u64 = members.getUint64(address).value();\n\n        // Calculate the fair share of tokens to disperse to this member based on the\n        // factor we just retrieved. Note that the result will be truncated.\n        let share: u64 = amount * factor / totalFactor;\n\n        // Is there anything to disperse to this member?\n        if (share > 0) {\n            // Yes, so let's set up an ScTransfer proxy that transfers the\n            // calculated amount of tokens.\n            let transfers: wasmlib.ScTransfer = wasmlib.ScTransfer.baseTokens(share);\n\n            // Perform the actual transfer of tokens from the caller allowance\n            // to the member account.\n            ctx.transferAllowed(address.asAgentID(), transfers, true);\n        }\n    }\n}\n")))),(0,r.kt)("p",null,"In the next section we will introduce ",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/funcdesc"},"function descriptors")," that can be\nused to initiate smart contract functions."))}h.isMDXComponent=!0},18679:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(67294),r=n(86010);const o="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,s),hidden:n},t)}},34259:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(87462),r=n(67294),o=n(86010),s=n(51048),i=n(33609),l=n(1943),c=n(72957);const m="tabList__CuJ",d="tabItem_LNqP";function u(e){var t;const{lazy:n,block:s,defaultValue:u,values:h,groupId:f,className:p}=e,b=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=h??b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),w=(0,i.l)(v,((e,t)=>e.value===t.value));if(w.length>0)throw new Error(`Docusaurus error: Duplicate values "${w.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===u?u:u??(null==(t=b.find((e=>e.props.default)))?void 0:t.props.value)??b[0].props.value;if(null!==y&&!v.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:k}=(0,l.U)(),[x,T]=(0,r.useState)(y),S=[],{blockElementScrollPositionUntilNextRender:C}=(0,c.o5)();if(null!=f){const e=g[f];null!=e&&e!==x&&v.some((t=>t.value===e))&&T(e)}const N=e=>{const t=e.currentTarget,n=S.indexOf(t),a=v[n].value;a!==x&&(C(t),T(a),null!=f&&k(f,String(a)))},_=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=S.indexOf(e.currentTarget)+1;n=S[t]??S[0];break}case"ArrowLeft":{const t=S.indexOf(e.currentTarget)-1;n=S[t]??S[S.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",m)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":s},p)},v.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:e=>S.push(e),onKeyDown:_,onFocus:N,onClick:N},s,{className:(0,o.Z)("tabs__item",d,null==s?void 0:s.className,{"tabs__item--active":x===t})}),n??t)}))),n?(0,r.cloneElement)(b.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==x})))))}function h(e){const t=(0,s.Z)();return r.createElement(u,(0,a.Z)({key:String(t)},e))}}}]);