"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[22189],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=i,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||a;return n?o.createElement(m,r(r({ref:t},u),{},{components:n})):o.createElement(m,r({ref:t},u))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<a;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},95876:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(87462),i=(n(67294),n(3905));const a={description:"Every network has to deal with its intrinsic limited resources. GoShimmer uses congestion control algorithm to regulate the influx of blocks in the network with the goal of maximizing throughput (blocks/bytes per second) and minimizing delays.",image:"/img/protocol_specification/congestion_control_algorithm_infographic_new.png",keywords:["node","congestion control algorithm","honest node","block","access mana","malicious nde","scheduling"]},r="Congestion Control",s={unversionedId:"protocol_specification/components/congestion_control",id:"protocol_specification/components/congestion_control",title:"Congestion Control",description:"Every network has to deal with its intrinsic limited resources. GoShimmer uses congestion control algorithm to regulate the influx of blocks in the network with the goal of maximizing throughput (blocks/bytes per second) and minimizing delays.",source:"@site/shimmer/external/goshimmer/documentation/docs/protocol_specification/components/congestion_control.md",sourceDirName:"protocol_specification/components",slug:"/protocol_specification/components/congestion_control",permalink:"/shimmer/goshimmer/protocol_specification/components/congestion_control",draft:!1,editUrl:"https://github.com/iotaledger/goshimmer/edit/develop/documentation/shimmer/external/goshimmer/documentation/docs/protocol_specification/components/congestion_control.md",tags:[],version:"current",frontMatter:{description:"Every network has to deal with its intrinsic limited resources. GoShimmer uses congestion control algorithm to regulate the influx of blocks in the network with the goal of maximizing throughput (blocks/bytes per second) and minimizing delays.",image:"/img/protocol_specification/congestion_control_algorithm_infographic_new.png",keywords:["node","congestion control algorithm","honest node","block","access mana","malicious nde","scheduling"]},sidebar:"docs",previous:{title:"Mana Implementation",permalink:"/shimmer/goshimmer/protocol_specification/components/mana"},next:{title:"Consensus Mechanism",permalink:"/shimmer/goshimmer/protocol_specification/components/consensus_mechanism"}},l={},c=[{value:"Detailed Design",id:"detailed-design",level:2},{value:"Prerequirements",id:"prerequirements",level:3},{value:"Outbox Buffer Management",id:"outbox-buffer-management",level:3},{value:"False positive drop",id:"false-positive-drop",level:4},{value:"False positive schedule",id:"false-positive-schedule",level:4},{value:"Scheduler",id:"scheduler",level:3},{value:"Rate Setting",id:"rate-setting",level:3}],u={toc:c};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,o.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"congestion-control"},"Congestion Control"),(0,i.kt)("p",null,"Every network has to deal with its limited intrinsic resources in bandwidth and node capabilities (CPU and\nstorage). In this document, we present a congestion control algorithm to regulate the influx of blocks in the\nnetwork to maximize throughput (blocks/bytes per second) and minimize delays. Furthermore, the\nfollowing requirements must be satisfied:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Consistency"),": If an honest node writes a block, it should be written by all honest nodes within some\ndelay bound."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Fairness"),": Nodes can obtain a share of the available throughput depending on their access Mana. Throughput is\nshared in a way that an attempt to increase the allocation of any node necessarily results in the decrease\nin the allocation of some other node with an equal or smaller allocation (max-min fairness)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Security"),": Malicious nodes shall be unable to interfere with either of the above requirements.")),(0,i.kt)("p",null,(0,i.kt)("a",{target:"_blank",href:n(29465).Z},(0,i.kt)("img",{alt:"Congestion Control",src:n(91187).Z,width:"690",height:"250"}))),(0,i.kt)("p",null,"You can find more information in the following papers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2005.07778"},"Access Control for Distributed Ledgers in the Internet of Things: A Networking Approach"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2107.10238"},"Secure Access Control for DAG-based Distributed Ledgers"),".")),(0,i.kt)("h2",{id:"detailed-design"},"Detailed Design"),(0,i.kt)("p",null,"The algorithm has three core components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A scheduling algorithm that ensures fair access for all nodes according to their access Mana."),(0,i.kt)("li",{parentName:"ul"},"A TCP-inspired algorithm for decentralized rate setting to utilize the available bandwidth efficiently while\npreventing large delays."),(0,i.kt)("li",{parentName:"ul"},"A buffer management policy to deal with malicious flows.")),(0,i.kt)("h3",{id:"prerequirements"},"Prerequirements"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Node identity"),": The congestion control module requires node accountability. Each block is associated with the node ID of its issuing\nnode.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Access mana"),": The congestion control module knows the access Mana of the network nodes to share the available\nthroughput fairly. Without access Mana, the network would be subject to Sybil attacks, which would incentivize actors\nto artificially split (or aggregate) onto multiple identities.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Block weight"),". The weight of a block is used to prioritize blocks over the others, and it is calculated\nbased on the type and length of a block."))),(0,i.kt)("h3",{id:"outbox-buffer-management"},"Outbox Buffer Management"),(0,i.kt)("p",null,"Once a block has successfully passed the block parser checks, is solid and booked, it is enqueued into the outbox\nbuffer for scheduling. The outbox is split into several queues, each corresponding to a different node issuing\nblocks. The total outbox buffer size is limited, but individual queues do not have a size limit. This section\ndescribes the operations of block enqueuing and dequeuing into and from the outbox buffer."),(0,i.kt)("p",null,"The enqueuing mechanism includes the following components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Classification"),": The mechanism identifies the queue where the block belongs according to the node ID of\nthe block issuer."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Block enqueuing"),": The block is actually enqueued, the queue is sorted by block timestamps in increasing order\nand counters are updated (e.g., counters for the total number of blocks in the queue).")),(0,i.kt)("p",null,"The dequeuing mechanism includes the following components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Queue selection"),": A queue is selected according to a round-robin scheduling algorithm. In particular, the\nmechanism uses a modified version of the deficit round-robin (DRR) algorithm."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Block dequeuing"),". The first (oldest) block of the queue, that satisfies certain conditions is dequeued. A\nblock must satisfy the following conditions:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The block has a ready flag assigned. A ready flag is assigned to a block when all of its parents are eligible (the parents have been scheduled or confirmed)."),(0,i.kt)("li",{parentName:"ul"},"The block timestamp is not in the future."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Block skipping"),'. Once a block in the outbox is confirmed by another block approving it, it will get removed from the outbox buffer. Since the block already has children and is supposed to be replicated on enough nodes in the network, it is not gossiped or added to the tip pool, hence "skipped".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Block drop"),": Due to the node's bootstrapping, network congestion, or ongoing attacks, the buffer occupancy of the outbox buffer may become large. To keep bounded delays and isolate the attacker's spam, a node shall drop some blocks if the total number of blocks in all queues exceeds the maximum buffer size. Particularly, the node will drop blocks from the queue with the largest mana-scaled length, computed by dividing the number of blocks in the queue by the amount of access Mana of the corresponding node.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Mana-scaled queue size = queue size / node aMana"),";"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Scheduler management"),": The scheduler counters and pointers are updated.")),(0,i.kt)("h4",{id:"false-positive-drop"},"False positive drop"),(0,i.kt)("p",null,"During an attack or congestion, a node may drop a block already scheduled by the rest of the network, causing a",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"false positive drop"),". This means that the block\u2019s future cone will not be marked as ",(0,i.kt)("em",{parentName:"p"},"ready")," as its past cone is not\neligible. This is not a problem because blocks dropped from the outbox are already booked and confirmation comes\neventually due to blocks received from the rest of the network which approve the dropped ones."),(0,i.kt)("h4",{id:"false-positive-schedule"},"False positive schedule"),(0,i.kt)("p",null,"Another possible problem is that a node schedules a block that the rest of the network drops, causing a ",(0,i.kt)("em",{parentName:"p"},"false\npositive"),". The block is gossiped and added to the tip pool. However, it will never accumulate enough approval\nweight to be ",(0,i.kt)("em",{parentName:"p"},"Confirmed"),". Eventually, the node will orphan this part of tangle as the blocks in the future-cone\nwill not pass the ",(0,i.kt)("a",{parentName:"p",href:"/shimmer/goshimmer/protocol_specification/components/tangle#tip-pool-and-time-since-confirmation-check"},"Time Since Confirmation check")," during tip\nselection."),(0,i.kt)("h3",{id:"scheduler"},"Scheduler"),(0,i.kt)("p",null,"Scheduling is the most critical task in the congestion control component. The scheduling algorithm must guarantee that\nan honest node ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," meets the following requirements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Consistency"),": The node's blocks will not accumulate indefinitely at any node, and so, starvation is avoided."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Fairness"),": The node's fair share of the network resources are allocated to it according to its access Mana."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Security"),": Malicious nodes sending above their allowed rate will not interrupt a node's throughput requirement.")),(0,i.kt)("p",null,"Although nodes in our setting are capable of more complex and customised behaviour than a typical router in a\npacket-switched network, our scheduler must still be lightweight and scalable due to the potentially large number of\nnodes requiring differentiated treatment. It is estimated that over 10,000 nodes operate on the Bitcoin network, and\nwe expect that an even greater number of nodes are likely to be present in the IoT setting. For this reason, we\nadopt a scheduler based on ",(0,i.kt)("a",{parentName:"p",href:"https://ieeexplore.ieee.org/document/502236"},"Deficit Round Robin")," (DRR) (the Linux\nimplementation of the ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc8290"},"FQ-CoDel packet scheduler"),", which is based on DRR,\nsupports anywhere up to 65535 separate queues)."),(0,i.kt)("p",null,"The DRR scans all non-empty queues in sequence. When it selects a non-empty queue, the DDR will increment the queue's\npriority counter (",(0,i.kt)("em",{parentName:"p"},"deficit"),") by a specific value (",(0,i.kt)("em",{parentName:"p"},"quantum"),"). Then, the value of the deficit counter is a maximal amount\nof bytes that can be sent this turn. If the deficit counter is greater than the weight of the block at the head of the\nqueue, the DRR can schedule this block, and this weight decrements the value of the counter. In our implementation,\nthe quantum is proportional to the node's access Mana, and we add a cap on the maximum deficit that a node can achieve\nto keep the network latency low. It is also important to mention that the DRR can assign the weight of the block so\nthat specific blocks can be prioritized (low weight) or penalized (large weight); by default, in our mechanism, the\nweight is proportional to the block size measured in bytes. The weight of a block is set by the\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"WorkCalculator()"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The network manager sets up the desired maximum (fixed) rate ",(0,i.kt)("inlineCode",{parentName:"p"},"SCHEDULING_RATE")," at which it will schedule blocks,\ncomputed in weight per second. This implies that every block is scheduled after a delay which is equal to the weight (\nsize as default) of the latest scheduled block times the parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"SCHEDULING_RATE"),". This rate mainly depends on the degree of decentralization you desire: a larger rate leads to\nhigher throughput but will leave behind slower devices that will fall out of sync.")),(0,i.kt)("h3",{id:"rate-setting"},"Rate Setting"),(0,i.kt)("p",null,"If nodes were continuously willing to issue new blocks,rate-setting would not be a problem. Nodes could simply operate\nat a fixed, assured rate and share the total throughput according to the percentage of access Mana they own. The\nscheduling algorithm would ensure that this rate is enforceable, and only misbehaving nodes would experience increasing\ndelays or dropped blocks. However, it is unrealistic to expect all nodes always to have blocks to issue. We would\nlike nodes to better utilize network resources without causing excessive congestion and violating any requirement."),(0,i.kt)("p",null,"We propose a rate-setting algorithm inspired by TCP \u2014 each node employs ","[additive increase, multiplicative decrease]","\n(https://",(0,i.kt)("a",{parentName:"p",href:"https://epubs.siam.org/doi/book/10.1137/1.9781611974225"},"https://epubs.siam.org/doi/book/10.1137/1.9781611974225"),") (AIMD) rules to update their issuance rate in response\nto congestion events. In the case of distributed ledgers, all block traffic passes through all nodes, contrary to the\ncase of traffic typically found in packet-switched networks and other traditional network architectures. Under these\nconditions, local congestion at a node is all that is required to indicate congestion elsewhere in the network. This\nobservation is crucial as it presents an opportunity for a congestion control algorithm based entirely on local traffic."),(0,i.kt)("p",null,"Our rate-setting algorithm outlines the AIMD rules employed by each node to set their issuance rate. Rate updates for a\nnode occur each time a new block is scheduled if the node has a non-empty set of its own blocks that are not yet\nscheduled. The node sets its own local additive-increase variable ",(0,i.kt)("inlineCode",{parentName:"p"},"localIncrease(node)")," based on its access Mana and a\nglobal increase rate parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"RATE_SETTING_INCREASE"),". An appropriate choice of\n",(0,i.kt)("inlineCode",{parentName:"p"},"RATE_SETTING_INCREASE")," ensures a conservative global increase rate that does not cause problems even when many nodes\nsimultaneously increase their rate."),(0,i.kt)("p",null,"Nodes wait ",(0,i.kt)("inlineCode",{parentName:"p"},"RATE_SETTING_PAUSE")," seconds after a global multiplicative decrease parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"RATE_SETTING_DECREASE"),", during\nwhich no further updates are made, to allow the reduced rate to take effect and prevent multiple successive decreases.\nAt each update, the node checks how many of its own blocks are in its outbox queue and responds with a multiplicative\ndecrease if this number is above a threshold,\n",(0,i.kt)("inlineCode",{parentName:"p"},"backoff(node)"),", which is proportional to the node's access Mana. If the number of the node's blocks in the outbox is\nbelow the threshold, the node's issuance rate is incremented by its local increase variable, ",(0,i.kt)("inlineCode",{parentName:"p"},"localIncrease(node)"),"."))}h.isMDXComponent=!0},29465:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/files/congestion_control_algorithm_infographic_new-54878545ddd53f9b38e761cc84cdc13c.png"},91187:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/congestion_control_algorithm_infographic_new-54878545ddd53f9b38e761cc84cdc13c.png"}}]);