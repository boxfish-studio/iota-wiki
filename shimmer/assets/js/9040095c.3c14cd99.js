"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[70851],{3905:(e,n,t)=>{t.d(n,{Zo:()=>o,kt:()=>p});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),u=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},o=function(e){var n=u(e.components);return a.createElement(i.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},w=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,c=e.originalType,i=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),w=u(t),p=r,b=w["".concat(i,".").concat(p)]||w[p]||m[p]||c;return t?a.createElement(b,s(s({ref:n},o),{},{components:t})):a.createElement(b,s({ref:n},o))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var c=t.length,s=new Array(c);s[0]=w;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var u=2;u<c;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}w.displayName="MDXCreateElement"},91643:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>u,toc:()=>m});var a=t(87462),r=(t(67294),t(3905)),c=t(34259),s=t(18679);const l={keywords:["descriptor","view","access","contract functions","schema tool"],description:"The schema tool provides us with an easy way to access to smart contract functions through function descriptors, which allow you to initiate the function by calling it synchronously, or posting a request to run it asynchronously.",image:"/img/logo/WASP_logo_dark.png"},i="Function Descriptors",u={unversionedId:"guide/wasm_vm/funcdesc",id:"guide/wasm_vm/funcdesc",title:"Function Descriptors",description:"The schema tool provides us with an easy way to access to smart contract functions through function descriptors, which allow you to initiate the function by calling it synchronously, or posting a request to run it asynchronously.",source:"@site/shimmer/external/wasp/documentation/docs/guide/wasm_vm/funcdesc.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/funcdesc",permalink:"/shimmer/smart-contracts/guide/wasm_vm/funcdesc",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/master/documentation/shimmer/external/wasp/documentation/docs/guide/wasm_vm/funcdesc.mdx",tags:[],version:"current",frontMatter:{keywords:["descriptor","view","access","contract functions","schema tool"],description:"The schema tool provides us with an easy way to access to smart contract functions through function descriptors, which allow you to initiate the function by calling it synchronously, or posting a request to run it asynchronously.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Token Transfers",permalink:"/shimmer/smart-contracts/guide/wasm_vm/transfers"},next:{title:"Calling Functions",permalink:"/shimmer/smart-contracts/guide/wasm_vm/call"}},o={},m=[],w={toc:m};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"function-descriptors"},"Function Descriptors"),(0,r.kt)("p",null,"The schema tool provides us with an easy way to access to smart contract functions through\n",(0,r.kt)("em",{parentName:"p"},"function descriptors"),". These are structures that provide access to the optional params\nand result maps through strict compile-time checked interfaces. They will also allow you\nto initiate the function by calling it ",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/call"},"synchronously"),", or posting a request to\nrun it ",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/post"},"asynchronously"),"."),(0,r.kt)("p",null,"The schema tool will generate a specific function descriptor for each func and view. It\nwill also generate an interface called ScFuncs, that can be used to create and initialize\neach function descriptor. Here is the code generated for the ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend")," example\nin ",(0,r.kt)("inlineCode",{parentName:"p"},"contract.xx"),":"),(0,r.kt)(c.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package dividend\n\nimport "github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib"\n\ntype DivideCall struct {\n    Func    *wasmlib.ScFunc\n}\n\ntype InitCall struct {\n    Func    *wasmlib.ScInitFunc\n    Params  MutableInitParams\n}\n\ntype MemberCall struct {\n    Func    *wasmlib.ScFunc\n    Params  MutableMemberParams\n}\n\ntype SetOwnerCall struct {\n    Func    *wasmlib.ScFunc\n    Params  MutableSetOwnerParams\n}\n\ntype GetFactorCall struct {\n    Func    *wasmlib.ScView\n    Params  MutableGetFactorParams\n    Results ImmutableGetFactorResults\n}\n\ntype GetOwnerCall struct {\n    Func    *wasmlib.ScView\n    Results ImmutableGetOwnerResults\n}\n\ntype Funcs struct{}\n\nvar ScFuncs Funcs\n\n// divide tokens over members\nfunc (sc Funcs) Divide(ctx wasmlib.ScFuncCallContext) *DivideCall {\n    return &DivideCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncDivide)}\n}\n\nfunc (sc Funcs) Init(ctx wasmlib.ScFuncCallContext) *InitCall {\n    f := &InitCall{Func: wasmlib.NewScInitFunc(ctx, HScName, HFuncInit)}\n    f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)\n    return f\n}\n\nfunc (sc Funcs) Member(ctx wasmlib.ScFuncCallContext) *MemberCall {\n    f := &MemberCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncMember)}\n    f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)\n    return f\n}\n\nfunc (sc Funcs) SetOwner(ctx wasmlib.ScFuncCallContext) *SetOwnerCall {\n    f := &SetOwnerCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncSetOwner)}\n    f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)\n    return f\n}\n\nfunc (sc Funcs) GetFactor(ctx wasmlib.ScViewCallContext) *GetFactorCall {\n    f := &GetFactorCall{Func: wasmlib.NewScView(ctx, HScName, HViewGetFactor)}\n    f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)\n    wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)\n    return f\n}\n\nfunc (sc Funcs) GetOwner(ctx wasmlib.ScViewCallContext) *GetOwnerCall {\n    f := &GetOwnerCall{Func: wasmlib.NewScView(ctx, HScName, HViewGetOwner)}\n    wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)\n    return f\n}\n'))),(0,r.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use wasmlib::*;\nuse crate::*;\n\npub struct DivideCall {\n    pub func: ScFunc,\n}\n\npub struct InitCall {\n    pub func: ScInitFunc,\n    pub params: MutableInitParams,\n}\n\npub struct MemberCall {\n    pub func: ScFunc,\n    pub params: MutableMemberParams,\n}\n\npub struct SetOwnerCall {\n    pub func: ScFunc,\n    pub params: MutableSetOwnerParams,\n}\n\npub struct GetFactorCall {\n    pub func: ScView,\n    pub params: MutableGetFactorParams,\n    pub results: ImmutableGetFactorResults,\n}\n\npub struct GetOwnerCall {\n    pub func: ScView,\n    pub results: ImmutableGetOwnerResults,\n}\n\npub struct ScFuncs {\n}\n\nimpl ScFuncs {\n    // divide tokens over members\n    pub fn divide(_ctx: &dyn ScFuncCallContext) -> DivideCall {\n        DivideCall {\n            func: ScFunc::new(HSC_NAME, HFUNC_DIVIDE),\n        }\n    }\n\n    pub fn init(_ctx: &dyn ScFuncCallContext) -> InitCall {\n        let mut f = InitCall {\n            func: ScInitFunc::new(HSC_NAME, HFUNC_INIT),\n            params: MutableInitParams { proxy: Proxy::nil() },\n        };\n        ScInitFunc::link_params(&mut f.params.proxy, &f.func);\n        f\n    }\n\n    pub fn member(_ctx: &dyn ScFuncCallContext) -> MemberCall {\n        let mut f = MemberCall {\n            func: ScFunc::new(HSC_NAME, HFUNC_MEMBER),\n            params: MutableMemberParams { proxy: Proxy::nil() },\n        };\n        ScFunc::link_params(&mut f.params.proxy, &f.func);\n        f\n    }\n\n    pub fn set_owner(_ctx: &dyn ScFuncCallContext) -> SetOwnerCall {\n        let mut f = SetOwnerCall {\n            func: ScFunc::new(HSC_NAME, HFUNC_SET_OWNER),\n            params: MutableSetOwnerParams { proxy: Proxy::nil() },\n        };\n        ScFunc::link_params(&mut f.params.proxy, &f.func);\n        f\n    }\n\n    pub fn get_factor(_ctx: &dyn ScViewCallContext) -> GetFactorCall {\n        let mut f = GetFactorCall {\n            func: ScView::new(HSC_NAME, HVIEW_GET_FACTOR),\n            params: MutableGetFactorParams { proxy: Proxy::nil() },\n            results: ImmutableGetFactorResults { proxy: Proxy::nil() },\n        };\n        ScView::link_params(&mut f.params.proxy, &f.func);\n        ScView::link_results(&mut f.results.proxy, &f.func);\n        f\n    }\n\n    pub fn get_owner(_ctx: &dyn ScViewCallContext) -> GetOwnerCall {\n        let mut f = GetOwnerCall {\n            func: ScView::new(HSC_NAME, HVIEW_GET_OWNER),\n            results: ImmutableGetOwnerResults { proxy: Proxy::nil() },\n        };\n        ScView::link_results(&mut f.results.proxy, &f.func);\n        f\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import * as wasmlib from "wasmlib";\nimport * as sc from "./index";\n\nexport class DivideCall {\n    func: wasmlib.ScFunc;\n    public constructor(ctx: wasmlib.ScFuncCallContext) {\n        this.func = new wasmlib.ScFunc(ctx, sc.HScName, sc.HFuncDivide);\n    }\n}\n\nexport class DivideContext {\n    state: sc.MutableDividendState = new sc.MutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class InitCall {\n    func: wasmlib.ScInitFunc;\n    params: sc.MutableInitParams = new sc.MutableInitParams(wasmlib.ScView.nilProxy);\n    public constructor(ctx: wasmlib.ScFuncCallContext) {\n        this.func = new wasmlib.ScInitFunc(ctx, sc.HScName, sc.HFuncInit);\n    }\n}\n\nexport class InitContext {\n    params: sc.ImmutableInitParams = new sc.ImmutableInitParams(wasmlib.paramsProxy());\n    state: sc.MutableDividendState = new sc.MutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class MemberCall {\n    func: wasmlib.ScFunc;\n    params: sc.MutableMemberParams = new sc.MutableMemberParams(wasmlib.ScView.nilProxy);\n    public constructor(ctx: wasmlib.ScFuncCallContext) {\n        this.func = new wasmlib.ScFunc(ctx, sc.HScName, sc.HFuncMember);\n    }\n}\n\nexport class MemberContext {\n    params: sc.ImmutableMemberParams = new sc.ImmutableMemberParams(wasmlib.paramsProxy());\n    state: sc.MutableDividendState = new sc.MutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class SetOwnerCall {\n    func: wasmlib.ScFunc;\n    params: sc.MutableSetOwnerParams = new sc.MutableSetOwnerParams(wasmlib.ScView.nilProxy);\n    public constructor(ctx: wasmlib.ScFuncCallContext) {\n        this.func = new wasmlib.ScFunc(ctx, sc.HScName, sc.HFuncSetOwner);\n    }\n}\n\nexport class SetOwnerContext {\n    params: sc.ImmutableSetOwnerParams = new sc.ImmutableSetOwnerParams(wasmlib.paramsProxy());\n    state: sc.MutableDividendState = new sc.MutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class GetFactorCall {\n    func: wasmlib.ScView;\n    params: sc.MutableGetFactorParams = new sc.MutableGetFactorParams(wasmlib.ScView.nilProxy);\n    results: sc.ImmutableGetFactorResults = new sc.ImmutableGetFactorResults(wasmlib.ScView.nilProxy);\n    public constructor(ctx: wasmlib.ScViewCallContext) {\n        this.func = new wasmlib.ScView(ctx, sc.HScName, sc.HViewGetFactor);\n    }\n}\n\nexport class GetFactorContext {\n    params: sc.ImmutableGetFactorParams = new sc.ImmutableGetFactorParams(wasmlib.paramsProxy());\n    results: sc.MutableGetFactorResults = new sc.MutableGetFactorResults(wasmlib.ScView.nilProxy);\n    state: sc.ImmutableDividendState = new sc.ImmutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class GetOwnerCall {\n    func: wasmlib.ScView;\n    results: sc.ImmutableGetOwnerResults = new sc.ImmutableGetOwnerResults(wasmlib.ScView.nilProxy);\n    public constructor(ctx: wasmlib.ScViewCallContext) {\n        this.func = new wasmlib.ScView(ctx, sc.HScName, sc.HViewGetOwner);\n    }\n}\n\nexport class GetOwnerContext {\n    results: sc.MutableGetOwnerResults = new sc.MutableGetOwnerResults(wasmlib.ScView.nilProxy);\n    state: sc.ImmutableDividendState = new sc.ImmutableDividendState(wasmlib.ScState.proxy());\n}\n\nexport class ScFuncs {\n    // divide tokens over members\n    static divide(ctx: wasmlib.ScFuncCallContext): DivideCall {\n        return new DivideCall(ctx);\n    }\n\n    static init(ctx: wasmlib.ScFuncCallContext): InitCall {\n        const f = new InitCall(ctx);\n        f.params = new sc.MutableInitParams(wasmlib.newCallParamsProxy(f.func));\n        return f;\n    }\n\n    static member(ctx: wasmlib.ScFuncCallContext): MemberCall {\n        const f = new MemberCall(ctx);\n        f.params = new sc.MutableMemberParams(wasmlib.newCallParamsProxy(f.func));\n        return f;\n    }\n\n    static setOwner(ctx: wasmlib.ScFuncCallContext): SetOwnerCall {\n        const f = new SetOwnerCall(ctx);\n        f.params = new sc.MutableSetOwnerParams(wasmlib.newCallParamsProxy(f.func));\n        return f;\n    }\n\n    static getFactor(ctx: wasmlib.ScViewCallContext): GetFactorCall {\n        const f = new GetFactorCall(ctx);\n        f.params = new sc.MutableGetFactorParams(wasmlib.newCallParamsProxy(f.func));\n        f.results = new sc.ImmutableGetFactorResults(wasmlib.newCallResultsProxy(f.func));\n        return f;\n    }\n\n    static getOwner(ctx: wasmlib.ScViewCallContext): GetOwnerCall {\n        const f = new GetOwnerCall(ctx);\n        f.results = new sc.ImmutableGetOwnerResults(wasmlib.newCallResultsProxy(f.func));\n        return f;\n    }\n}\n')))),(0,r.kt)("p",null,"As you can see a struct has been generated for each of the Funcs and Views. The structs\nonly provide access to ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," when these are specified for the function.\nEach struct has a ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," member that can be used to initiate the function call in certain\nways. The ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," member will be of type ScFunc or ScView, depending on whether the\nfunction is a func or a view."),(0,r.kt)("p",null,"The ScFuncs struct provides a member function for each func or view that will create their\nrespective function descriptor, initialize it properly, and returns it."),(0,r.kt)("p",null,"In the next section we will look at how to use function descriptors to\n",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/call"},"synchronously call")," smart contract functions on the same chain."))}p.isMDXComponent=!0},18679:(e,n,t)=>{t.d(n,{Z:()=>s});var a=t(67294),r=t(86010);const c="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(c,s),hidden:t},n)}},34259:(e,n,t)=>{t.d(n,{Z:()=>p});var a=t(87462),r=t(67294),c=t(86010),s=t(51048),l=t(33609),i=t(1943),u=t(72957);const o="tabList__CuJ",m="tabItem_LNqP";function w(e){var n;const{lazy:t,block:s,defaultValue:w,values:p,groupId:b,className:f}=e,d=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),x=p??d.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),y=(0,l.l)(x,((e,n)=>e.value===n.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const S=null===w?w:w??(null==(n=d.find((e=>e.props.default)))?void 0:n.props.value)??d[0].props.value;if(null!==S&&!x.some((e=>e.value===S)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${S}" but none of its children has the corresponding value. Available values are: ${x.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:C,setTabGroupChoices:h}=(0,i.U)(),[v,F]=(0,r.useState)(S),g=[],{blockElementScrollPositionUntilNextRender:P}=(0,u.o5)();if(null!=b){const e=C[b];null!=e&&e!==v&&x.some((n=>n.value===e))&&F(e)}const O=e=>{const n=e.currentTarget,t=g.indexOf(n),a=x[t].value;a!==v&&(P(n),F(a),null!=b&&h(b,String(a)))},I=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=g.indexOf(e.currentTarget)+1;t=g[n]??g[0];break}case"ArrowLeft":{const n=g.indexOf(e.currentTarget)-1;t=g[n]??g[g.length-1];break}}null==(n=t)||n.focus()};return r.createElement("div",{className:(0,c.Z)("tabs-container",o)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":s},f)},x.map((e=>{let{value:n,label:t,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===n?0:-1,"aria-selected":v===n,key:n,ref:e=>g.push(e),onKeyDown:I,onFocus:O,onClick:O},s,{className:(0,c.Z)("tabs__item",m,null==s?void 0:s.className,{"tabs__item--active":v===n})}),t??n)}))),t?(0,r.cloneElement)(d.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},d.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==v})))))}function p(e){const n=(0,s.Z)();return r.createElement(w,(0,a.Z)({key:String(n)},e))}}}]);