"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[56996],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(a),p=r,h=m["".concat(l,".").concat(p)]||m[p]||d[p]||s;return a?n.createElement(h,o(o({ref:t},u),{},{components:a})):n.createElement(h,o({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},28201:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var n=a(87462),r=(a(67294),a(3905)),s=a(34259),o=a(18679);const i={keywords:["state","access","storage","key","data","value"],description:"The smart contract state storage on the host consists of a single key/value map, as long as you access the data in the same way that you used to store it, you will always get valid data back.",image:"/img/logo/WASP_logo_dark.png"},l="Smart Contract State",c={unversionedId:"guide/wasm_vm/state",id:"guide/wasm_vm/state",title:"Smart Contract State",description:"The smart contract state storage on the host consists of a single key/value map, as long as you access the data in the same way that you used to store it, you will always get valid data back.",source:"@site/shimmer/external/wasp/documentation/docs/guide/wasm_vm/state.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/state",permalink:"/shimmer/smart-contracts/guide/wasm_vm/state",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/master/documentation/shimmer/external/wasp/documentation/docs/guide/wasm_vm/state.mdx",tags:[],version:"current",frontMatter:{keywords:["state","access","storage","key","data","value"],description:"The smart contract state storage on the host consists of a single key/value map, as long as you access the data in the same way that you used to store it, you will always get valid data back.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Type Definitions",permalink:"/shimmer/smart-contracts/guide/wasm_vm/typedefs"},next:{title:"Triggering Events",permalink:"/shimmer/smart-contracts/guide/wasm_vm/events"}},u={},d=[],m={toc:d};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"smart-contract-state"},"Smart Contract State"),(0,r.kt)("p",null,"The smart contract state storage on the host consists of a single key/value map. Both key\nand value are raw data bytes. As long as you access the data in the same way that you used\nto store it, you will always get valid data back. The schema tool will create a type-safe\naccess layer to make sure that data storage and retrieval always uses the expected data\ntype."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," section in the schema definition file contains a number of field definitions\nthat together define the variables that are stored in the state storage. Each field\ndefinition uses a YAML key/value pair to define the name and data type of the field.\nThe YAML key defines the field name. The YAML value (a string) defines the field's data\ntype, and can be followed by an optional comment that describes the field."),(0,r.kt)("p",null,"The schema tool will use this information to generate the specific code that accesses the\nstate variables in a type-safe way. Let's examine the ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," section of the ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend"),"\nexample in more detail:"),(0,r.kt)(s.Z,{defaultValue:"yaml",values:[{label:"schema.yaml",value:"yaml"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"state:\n  memberList: Address[] # array with all the recipients of this dividend\n\n  # factors per member\n\n  members: map[Address]Uint64 # map with all the recipient factors of this dividend\n  owner: AgentID # owner of contract, the only one who can call 'member' func\n  totalFactor: Uint64 # sum of all recipient factors\n")))),(0,r.kt)("p",null,"Let's start with the simplest state variables. ",(0,r.kt)("inlineCode",{parentName:"p"},"totalFactor")," is an Uint64, and ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," is\nan AgentID. Both are predefined ",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/types"},"WasmLib value types"),"."),(0,r.kt)("p",null,"Then you have the ",(0,r.kt)("inlineCode",{parentName:"p"},"memberList")," variable. The empty brackets ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," indicate that this is an\narray. The brackets immediately follow the homogenous type of the elements in the array,\nwhich in this case is the predefined Address value type."),(0,r.kt)("p",null,"Finally, you have the ",(0,r.kt)("inlineCode",{parentName:"p"},"members")," variable. The ",(0,r.kt)("inlineCode",{parentName:"p"},"map[]")," indicates that this is a map.\nBetween the brackets is the homogenous type of the keys, which in this case are of the\npredefined Address type. The brackets are immediately followed by the homogenous type of\nthe values in the map, which in this case are of the predefined Uint64 type."),(0,r.kt)("p",null,"Here is part of the corresponding code in ",(0,r.kt)("inlineCode",{parentName:"p"},"state.xx")," that the schema tool generates.\nThe MutableDividendState struct defines a type-safe interface to access each of the state\nvariables through mutable proxies:"),(0,r.kt)(s.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type MutableDividendState struct {\n    proxy wasmtypes.Proxy\n}\n\nfunc (s MutableDividendState) AsImmutable() ImmutableDividendState {\n    return ImmutableDividendState(s)\n}\n\n// array with all the recipients of this dividend\nfunc (s MutableDividendState) MemberList() ArrayOfMutableAddress {\n    return ArrayOfMutableAddress{proxy: s.proxy.Root(StateMemberList)}\n}\n\n// map with all the recipient factors of this dividend\nfunc (s MutableDividendState) Members() MapAddressToMutableUint64 {\n    return MapAddressToMutableUint64{proxy: s.proxy.Root(StateMembers)}\n}\n\n// owner of contract, the only one who can call 'member' func\nfunc (s MutableDividendState) Owner() wasmtypes.ScMutableAgentID {\n    return wasmtypes.NewScMutableAgentID(s.proxy.Root(StateOwner))\n}\n\n// sum of all recipient factors\nfunc (s MutableDividendState) TotalFactor() wasmtypes.ScMutableUint64 {\n    return wasmtypes.NewScMutableUint64(s.proxy.Root(StateTotalFactor))\n}\n"))),(0,r.kt)(o.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone)]\npub struct MutableDividendState {\n    pub(crate) proxy: Proxy,\n}\n\nimpl MutableDividendState {\n    pub fn as_immutable(&self) -> ImmutableDividendState {\n        ImmutableDividendState { proxy: self.proxy.root(\"\") }\n    }\n\n    // array with all the recipients of this dividend\n    pub fn member_list(&self) -> ArrayOfMutableAddress {\n        ArrayOfMutableAddress { proxy: self.proxy.root(STATE_MEMBER_LIST) }\n    }\n\n    // map with all the recipient factors of this dividend\n    pub fn members(&self) -> MapAddressToMutableUint64 {\n        MapAddressToMutableUint64 { proxy: self.proxy.root(STATE_MEMBERS) }\n    }\n\n    // owner of contract, the only one who can call 'member' func\n    pub fn owner(&self) -> ScMutableAgentID {\n        ScMutableAgentID::new(self.proxy.root(STATE_OWNER))\n    }\n\n    // sum of all recipient factors\n    pub fn total_factor(&self) -> ScMutableUint64 {\n        ScMutableUint64::new(self.proxy.root(STATE_TOTAL_FACTOR))\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export class MutableDividendState extends wasmtypes.ScProxy {\n    asImmutable(): sc.ImmutableDividendState {\n        return new sc.ImmutableDividendState(this.proxy);\n    }\n\n    // array with all the recipients of this dividend\n    memberList(): sc.ArrayOfMutableAddress {\n        return new sc.ArrayOfMutableAddress(this.proxy.root(sc.StateMemberList));\n    }\n\n    // map with all the recipient factors of this dividend\n    members(): sc.MapAddressToMutableUint64 {\n        return new sc.MapAddressToMutableUint64(this.proxy.root(sc.StateMembers));\n    }\n\n    // owner of contract, the only one who can call 'member' func\n    owner(): wasmtypes.ScMutableAgentID {\n        return new wasmtypes.ScMutableAgentID(this.proxy.root(sc.StateOwner));\n    }\n\n    // sum of all recipient factors\n    totalFactor(): wasmtypes.ScMutableUint64 {\n        return new wasmtypes.ScMutableUint64(this.proxy.root(sc.StateTotalFactor));\n    }\n}\n")))),(0,r.kt)("p",null,"As you can see, the schema tool has generated a proxy interface for the mutable ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend"),"\nstate, called ",(0,r.kt)("inlineCode",{parentName:"p"},"MutableDividendState"),". It has a 1-to-1 correspondence to the ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),"\nsection in the schema definition file. Each member function accesses a type-safe proxy\nobject for the corresponding variable. In addition, the schema tool generates any\nnecessary intermediate map and array proxy types that force the usage of their respective\nhomogenous types. In the above example both ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayOfMutableAddress")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"MapAddressToMutableUint64")," are examples of such automatically generated proxy types.\nSee the full ",(0,r.kt)("inlineCode",{parentName:"p"},"state.xx")," for more details."),(0,r.kt)("p",null,"In the next section we will explore how the schema tool helps to simplify\n",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/events"},"triggering events"),"."))}p.isMDXComponent=!0},18679:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(67294),r=a(86010);const s="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,o),hidden:a},t)}},34259:(e,t,a)=>{a.d(t,{Z:()=>p});var n=a(87462),r=a(67294),s=a(86010),o=a(51048),i=a(33609),l=a(1943),c=a(72957);const u="tabList__CuJ",d="tabItem_LNqP";function m(e){var t;const{lazy:a,block:o,defaultValue:m,values:p,groupId:h,className:f}=e,y=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=p??y.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),v=(0,i.l)(b,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===m?m:m??(null==(t=y.find((e=>e.props.default)))?void 0:t.props.value)??y[0].props.value;if(null!==g&&!b.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:k}=(0,l.U)(),[T,x]=(0,r.useState)(g),S=[],{blockElementScrollPositionUntilNextRender:M}=(0,c.o5)();if(null!=h){const e=w[h];null!=e&&e!==T&&b.some((t=>t.value===e))&&x(e)}const A=e=>{const t=e.currentTarget,a=S.indexOf(t),n=b[a].value;n!==T&&(M(t),x(n),null!=h&&k(h,String(n)))},N=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=S.indexOf(e.currentTarget)+1;a=S[t]??S[0];break}case"ArrowLeft":{const t=S.indexOf(e.currentTarget)-1;a=S[t]??S[S.length-1];break}}null==(t=a)||t.focus()};return r.createElement("div",{className:(0,s.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":o},f)},b.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>S.push(e),onKeyDown:N,onFocus:A,onClick:A},o,{className:(0,s.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":T===t})}),a??t)}))),a?(0,r.cloneElement)(y.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},y.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function p(e){const t=(0,o.Z)();return r.createElement(m,(0,n.Z)({key:String(t)},e))}}}]);