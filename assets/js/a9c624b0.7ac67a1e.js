"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[29299],{10782:(e,n,t)=>{t.d(n,{ZP:()=>s});var a=t(87462),i=(t(67294),t(3905));const o={toc:[]};function s(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Password Storage",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"It is not recommended to store passwords or seeds on a host's environment variables or in the source code in a production\nsetup. Please follow our ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/backup_security"},"backup and security"),"\nrecommendations for production use.")))}s.isMDXComponent=!0},58847:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>B,contentTitle:()=>P,default:()=>j,frontMatter:()=>A,metadata:()=>L,toc:()=>Z});var a=t(87462),i=(t(67294),t(3905)),o=t(34259),s=t(18679),l=t(10782),r=t(69319);const d={toc:[]};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Load Balancers & Health Checks",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If you use node load balancers then the health check may be useless as the follow-up API calls may be served by a\ndifferent node behind the load balancer that may not have been checked. You should be aware of this fact and trust that the\nload balancer participates only with nodes that are in healthy state. The ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," library additionally supports\na management of internal node pool, so you can mimic a load-balancer-like behavior using this feature locally.")))}p.isMDXComponent=!0;const c={toc:[]};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can instantiate the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client"),", and optionally configure it, by chaining calls to the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ClientBuilder")," helper class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ClientBuilder")," helper class provides several chaining calls through which the process\ncan be closely managed."))}u.isMDXComponent=!0;var m=t(49962);const h=m.Z.indexOf("public static void nodeInfo() {"),g=m.Z.indexOf("public static void generateSeed() {"),y=m.Z.substring(h,g),f=(k="GetInfoOutput",function(e){return console.warn("Component "+k+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var k;const w={toc:[]};function b(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{className:"language-java",mdxType:"CodeBlock"},y),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example")," of the ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#getinfo-nodeinfowrapper"},(0,i.kt)("inlineCode",{parentName:"a"},"getInfo()"))," function of the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#client"},(0,i.kt)("inlineCode",{parentName:"a"},"Client"))," instance:"),(0,i.kt)(f,{mdxType:"GetInfoOutput"}),(0,i.kt)(p,{mdxType:"LoadBalancerHealthChecks"}),(0,i.kt)(u,{mdxType:"ClientBuilder"}),(0,i.kt)("p",null,"The most common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".withNetwork(string)"),": Can be either ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs\nthe library whether to automatically select devnet nodes or mainnet nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".withNode(string)"),": Specify address of actual running IOTA node that should be used\nto communicate with in the format ",(0,i.kt)("inlineCode",{parentName:"li"},"https://node:port"),"). For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".withNodePoolUrls(String[])"),": The library also supports managing a pool of\nnodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based\non their sync status. If you provide ",(0,i.kt)("inlineCode",{parentName:"li"},".withNodePoolUrls(String[])"),", then the library periodically will periodically\ncheck\nwhether node is in sync or\nnot by calling ",(0,i.kt)("inlineCode",{parentName:"li"},".withNodeSyncInterval(float)"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".withLocalPow(boolean)"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},".localPow (True)")," a Proof-of-work will be done\nlocally and not remotely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".withNodeSyncDisabled()"),": When called, the library will use nodes that\nare ",(0,i.kt)("strong",{parentName:"li"},"not")," in sync with network. This parameter is usually useful if you would like to interact with a local test node\nthat is not fully synced. ",(0,i.kt)("strong",{parentName:"li"},"This parameter should not be used in production"),".")))}b.isMDXComponent=!0;const N={toc:[]};function C(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},N,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "nodeinfo":{\n      "name":"HORNET",\n      "version":"0.6.0-alpha",\n      "isHealthy":true,\n      "networkId":"migration",\n      "bech32HRP":"atoi",\n      "minPoWScore":100,\n      "messagesPerSecond":4.2,\n      "referencedMessagesPerSecond":4.1,\n      "referencedRate":97.61904761904762,\n      "latestMilestoneTimestamp":1618139001,\n      "latestMilestoneIndex":7092,\n      "confirmedMilestoneIndex":7092,\n      "pruningIndex":0,\n      "features":[\n         "PoW"\n      ]\n   },\n   "url":"https://api.lb-0.h.chrysalis-devnet.iota.cafe"\n}\n')),(0,i.kt)("p",null,"The most important properties are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isHealthy"),': Indicates whether the given node is in sync with the network and therefore safe to use. Even if a node is\nup and running, it may not be fully prepared to process your API calls properly. The node should be "synced", meaning\nthat it should be aware of all transactions in the Tangle. It is better to avoid interacting with nodes which are not\nfully synced.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bech32HRP"),": Indicates whether the given node is a part of ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/devnet"},"devnet"),"\n(",(0,i.kt)("inlineCode",{parentName:"li"},"atoi"),") or ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/mainnet"},"mainnet")," (",(0,i.kt)("inlineCode",{parentName:"li"},"iota"),"). You can find more info regarding the\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"IOTA address format")," in the official\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/welcome"},"Chrysalis documentation"),".")))}C.isMDXComponent=!0;const v={toc:[]};function _(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{className:"language-javascript",mdxType:"CodeBlock"},"\nfunction run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder()\n        .localPow(true)\n        .build();\n\n    client.getInfo().then(console.log).catch(console.error);\n}\n\nrun()\n"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"getInfo()")," function of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance:"),(0,i.kt)(C,{mdxType:"GetInfoOutput"}),(0,i.kt)(p,{mdxType:"LoadBalancerHealthChecks"}),(0,i.kt)(u,{mdxType:"ClientBuilder"}),(0,i.kt)("p",null,"The most common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".network(str)"),": Can be either ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs\nthe library whether to automatically select devnet nodes or mainnet nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".node(url)"),": Specify address of actual running IOTA node that should be used\nto communicate with in the format ",(0,i.kt)("inlineCode",{parentName:"li"},"https://node:port"),"). For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".nodePoolUrls(urls)"),": The library also supports managing a pool of\nnodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based\non their sync status. If you provide ",(0,i.kt)("inlineCode",{parentName:"li"},".nodePoolUrls(urls)"),", then the library periodically will periodically check whether node is in sync or\nnot by calling ",(0,i.kt)("inlineCode",{parentName:"li"},".nodeSyncInterval(interval)"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".localPow(bool)"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},".localPow (True)")," a Proof-of-work will be done\nlocally and not remotely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".disableNodeSync()"),": When called, the library will use nodes that\nare ",(0,i.kt)("strong",{parentName:"li"},"not")," in sync with network. This parameter is usually useful if you would like to interact with a local test node\nthat is not fully synced. ",(0,i.kt)("strong",{parentName:"li"},"This parameter should not be used in production"),".")),(0,i.kt)("p",null,"The following example uses additional initialization chaining calls, such as leveraging a custom node:"),(0,i.kt)(r.Z,{className:"language-javascript",mdxType:"CodeBlock"},"\nfunction run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder()\n        .node('https://api.lb-0.h.chrysalis-devnet.iota.cafe:443')    // custom node\n        .localPow(true)                                         // pow is done locally\n        .disableNodeSync()                                      // even non-synced node is fine - do not use in production\n        .build();\n\n    client.getInfo().then(console.log).catch(console.error);\n}\n\nrun()\n"))}_.isMDXComponent=!0;const T={toc:[]};function x(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "nodeinfo":{\n      "name":"HORNET",\n      "version":"0.6.0-alpha",\n      "is_healthy":true,\n      "network_id":"migration",\n      "bech32_hrp":"atoi",\n      "min_pow_score":100,\n      "messages_per_second":4.2,\n      "referenced_messages_per_second":4.1,\n      "referenced_rate":97.61904761904762,\n      "latest_milestone_timestamp":1618139001,\n      "latest_milestone_index":7092,\n      "confirmed_milestone_index":7092,\n      "pruning_index":0,\n      "features":[\n         "PoW"\n      ]\n   },\n   "url":"https://api.lb-0.h.chrysalis-devnet.iota.cafe"\n}\n')),(0,i.kt)("p",null,"The most important properties are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_healthy"),': Indicates whether the given node is in sync with the network and therefore safe to use. Even if a node is\nup and running, it may not be fully prepared to process your API calls properly. The node should be "synced", meaning\nthat it should be aware of all transactions in the Tangle. It is better to avoid interacting with nodes which are not\nfully synced.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bech32_hrp"),": Indicates whether the given node is a part of ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/devnet"},"devnet"),"\n(",(0,i.kt)("inlineCode",{parentName:"li"},"atoi"),") or ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/mainnet"},"mainnet")," (",(0,i.kt)("inlineCode",{parentName:"li"},"iota"),"). You can find more info regarding the\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"IOTA address format")," in the official\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/welcome"},"Chrysalis documentation"),".")))}x.isMDXComponent=!0;const S={toc:[]};function I(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{className:"language-python",mdxType:"CodeBlock"},"import iota_client\n\n# create a client with a node\nclient = iota_client.Client(\n    nodes_name_password=[['https://api.lb-0.h.chrysalis-devnet.iota.cafe']])\n\nprint(client.get_info())\n"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"get_info()")," function of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," class:"),(0,i.kt)(x,{mdxType:"GetInfoOutput"}),(0,i.kt)(p,{mdxType:"LoadBalancerHealthChecks"}),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," class constructor provides several parameters via which the process can be closely managed."),(0,i.kt)("p",null,"The most common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"network"),": Can be either ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs the library whether to automatically select devnet\nnodes or mainnet nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node"),": Specify address of actual running IOTA node that should be used to communicate with in the format\n",(0,i.kt)("inlineCode",{parentName:"li"},"https://node:port"),"). For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node_pool_urls"),": The library also supports managing a pool of nodes. You can provide a list of nodes and the\nlibrary manages the access to them automatically by selecting them based on their sync status. If you provide\n",(0,i.kt)("inlineCode",{parentName:"li"},"node_pool_urls"),", then the library periodically will periodically check whether node is in sync or not by calling\n",(0,i.kt)("inlineCode",{parentName:"li"},".node_sync_interval"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"local_pow"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},"local_pow==True")," (default value) a Proof-of-work will be done locally and not remotely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node_sync_disabled"),": When called, the library will use nodes that are ",(0,i.kt)("strong",{parentName:"li"},"not")," in sync with network. This\nparameter is usually useful if you would like to interact with a local test node that is not fully synced. ",(0,i.kt)("strong",{parentName:"li"},"This\nparameter should not be used in production"),".")))}I.isMDXComponent=!0;const E={toc:[]};function M(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example 01_get_info --release\n\nuse iota_client::Client;\n\n/// In this example we will get information about the node\n\n#[tokio::main]\nasync fn main() {\n    // Create a client instance\n    let iota = Client::builder()\n        .with_node("https://api.lb-0.h.chrysalis-devnet.iota.cafe") // Insert your node URL here\n        // Node with optional authentication\n        // .with_node_auth(\n        //     "https://somechrysalisiotanode.com",\n        //     Some("Some JWT"),\n        //     Some(("name", "password")),\n        // )\n        .unwrap()\n        .finish()\n        .await\n        .unwrap();\n\n    let info = iota.get_info().await.unwrap();\n    println!("Node Info: {:?}", info);\n}\n'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"get_info()")," function of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance:"),(0,i.kt)(x,{mdxType:"GetInfoOutput"}),(0,i.kt)(p,{mdxType:"LoadBalancerHealthChecks"}),(0,i.kt)(u,{mdxType:"ClientBuilder"}),(0,i.kt)("p",null,"The most common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".with_network(self, network: &str)"),": Can be either ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs\nthe library whether to automatically select devnet nodes or mainnet nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".with_node.(self, url: &str)"),": Specify address of actual running IOTA node that should be used\nto communicate with in the format ",(0,i.kt)("inlineCode",{parentName:"li"},"https://node:port"),"). For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".with_node_pool_urls(self, node_pool_urls: &[String]) "),": The library also supports managing a pool of\nnodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based\non their sync status. If you provide ",(0,i.kt)("inlineCode",{parentName:"li"},".node_pool_urls(urls)"),", then the library periodically will periodically check whether node is in sync or\nnot by calling ",(0,i.kt)("inlineCode",{parentName:"li"},".with_node_sync_interval(self, node_sync_interval: Duration)"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".with_local_pow(self, local: bool)"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},".with_local_pow(True)")," a Proof-of-work will be done\nlocally and not remotely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},". with_node_sync_disabled(self)"),": When called, the library will use nodes that\nare ",(0,i.kt)("strong",{parentName:"li"},"not")," in sync with network. This parameter is usually useful if you would like to interact with a local test node\nthat is not fully synced. ",(0,i.kt)("strong",{parentName:"li"},"This parameter should not be used in production"),".")))}M.isMDXComponent=!0;const O={toc:[]};function D(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},O,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{className:"language-javascript",mdxType:"CodeBlock"},"const { ClientBuilder } = require('../node/')\n\nasync function run() {\n    let client = await new ClientBuilder()\n        .node(\"https://api.lb-0.h.chrysalis-devnet.iota.cafe\")\n        .build();\n    // Get the nodeinfo\n    console.log(await client.getInfo());\n}\nrun()\n"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"getInfo()")," function of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance:"),(0,i.kt)(C,{mdxType:"GetInfoOutput"}),(0,i.kt)(p,{mdxType:"LoadBalancerHealthChecks"}),(0,i.kt)(u,{mdxType:"ClientBuilder"}),(0,i.kt)("p",null,"The most common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".network(str)"),": Can be either ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs\nthe library whether to automatically select devnet nodes or mainnet nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".node(url)"),": Specify address of actual running IOTA node that should be used\nto communicate with in the format ",(0,i.kt)("inlineCode",{parentName:"li"},"https://node:port"),"). For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".nodePoolUrls(urls)"),": The library also supports managing a pool of\nnodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based\non their sync status. If you provide ",(0,i.kt)("inlineCode",{parentName:"li"},".nodePoolUrls(urls)"),", then the library periodically will periodically check whether node is in sync or\nnot by calling ",(0,i.kt)("inlineCode",{parentName:"li"},".nodeSyncInterval(interval)"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".localPow(bool)"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},".localPow (True)")," a Proof-of-work will be done\nlocally and not remotely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".disableNodeSync()"),": When called, the library will use nodes that\nare ",(0,i.kt)("strong",{parentName:"li"},"not")," in sync with network. This parameter is usually useful if you would like to interact with a local test node\nthat is not fully synced. ",(0,i.kt)("strong",{parentName:"li"},"This parameter should not be used in production"),".")),(0,i.kt)("p",null,"The following example uses additional initialization chaining calls, such as leveraging a custom node:"),(0,i.kt)(r.Z,{className:"language-javascript",mdxType:"CodeBlock"},"\nasync function run() {\n    const { ClientBuilder } = require('../node')\n\n    // client will connect to testnet by default\n    const client = await new ClientBuilder()\n        .node('https://api.lb-0.h.chrysalis-devnet.iota.cafe:443')    // custom node\n        .localPow(true)                                         // pow is done locally\n        .build();\n\n    client.getInfo().then(console.log).catch(console.error);\n}\n\nrun()\n"))}D.isMDXComponent=!0;const A={title:"Get Node Information",description:"You can access all the features of the iota.rs library using an instance of the Client class. The Client class provides high-level abstraction to all interactions over IOTA network (Tangle).",image:"/img/logo/iota_mark_light.png",keywords:["how to","client class","iota node","ClientBuilder","load balancer","java","nodejs","python","rust","wasm"]},P="Connecting to Node(s)",L={unversionedId:"examples/get_info",id:"examples/get_info",title:"Get Node Information",description:"You can access all the features of the iota.rs library using an instance of the Client class. The Client class provides high-level abstraction to all interactions over IOTA network (Tangle).",source:"@site/iota/external/iota.rs/production/documentation/docs/examples/get_info.mdx",sourceDirName:"examples",slug:"/examples/get_info",permalink:"/iota.rs/examples/get_info",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/production/documentation/iota/external/iota.rs/production/documentation/docs/examples/get_info.mdx",tags:[],version:"current",frontMatter:{title:"Get Node Information",description:"You can access all the features of the iota.rs library using an instance of the Client class. The Client class provides high-level abstraction to all interactions over IOTA network (Tangle).",image:"/img/logo/iota_mark_light.png",keywords:["how to","client class","iota node","ClientBuilder","load balancer","java","nodejs","python","rust","wasm"]},sidebar:"docs",previous:{title:"Running Examples",permalink:"/iota.rs/examples/running_examples"},next:{title:"Generate a Seed",permalink:"/iota.rs/examples/generate_seed"}},B={},Z=[],U={toc:Z};function j(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},U,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"connecting-to-nodes"},"Connecting to Node(s)"),(0,i.kt)("p",null,"You can access all the features of the ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," library using an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," class\nprovides high-level abstraction to all interactions over IOTA network (Tangle). You have to instantiate this class\nbefore you start any interactions with the library, or more precisely with the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/node_software"},"IOTA nodes")," that power IOTA network."),(0,i.kt)("p",null,"The library is designed to automatically choose a starting IOTA node based on the network type you would like to\nparticipate in: ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/devnet"},(0,i.kt)("inlineCode",{parentName:"a"},"devnet"))," or\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/mainnet"},(0,i.kt)("inlineCode",{parentName:"a"},"mainnet")),"."),(0,i.kt)(l.ZP,{mdxType:"WarningPasswordStorage"}),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(b,{mdxType:"JavaGetInfo"})),(0,i.kt)(s.Z,{value:"nodejs",label:"Nodejs",mdxType:"TabItem"},(0,i.kt)(_,{mdxType:"NodejsGetInfo"})),(0,i.kt)(s.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(I,{mdxType:"PythonGetInfo"})),(0,i.kt)(s.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,i.kt)(M,{mdxType:"RustGetInfo"})),(0,i.kt)(s.Z,{value:"wasm",label:"Wasm",mdxType:"TabItem"},(0,i.kt)(D,{mdxType:"WasmGetInfo"}))))}j.isMDXComponent=!0},18679:(e,n,t)=>{t.d(n,{Z:()=>s});var a=t(67294),i=t(86010);const o="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o,s),hidden:t},n)}},34259:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(87462),i=t(67294),o=t(86010),s=t(51048),l=t(33609),r=t(1943),d=t(72957);const p="tabList__CuJ",c="tabItem_LNqP";function u(e){var n;const{lazy:t,block:s,defaultValue:u,values:m,groupId:h,className:g}=e,y=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=m??y.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),k=(0,l.l)(f,((e,n)=>e.value===n.value));if(k.length>0)throw new Error(`Docusaurus error: Duplicate values "${k.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const w=null===u?u:u??(null==(n=y.find((e=>e.props.default)))?void 0:n.props.value)??y[0].props.value;if(null!==w&&!f.some((e=>e.value===w)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${w}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:b,setTabGroupChoices:N}=(0,r.U)(),[C,v]=(0,i.useState)(w),_=[],{blockElementScrollPositionUntilNextRender:T}=(0,d.o5)();if(null!=h){const e=b[h];null!=e&&e!==C&&f.some((n=>n.value===e))&&v(e)}const x=e=>{const n=e.currentTarget,t=_.indexOf(n),a=f[t].value;a!==C&&(T(n),v(a),null!=h&&N(h,String(a)))},S=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=_.indexOf(e.currentTarget)+1;t=_[n]??_[0];break}case"ArrowLeft":{const n=_.indexOf(e.currentTarget)-1;t=_[n]??_[_.length-1];break}}null==(n=t)||n.focus()};return i.createElement("div",{className:(0,o.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":s},g)},f.map((e=>{let{value:n,label:t,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===n?0:-1,"aria-selected":C===n,key:n,ref:e=>_.push(e),onKeyDown:S,onFocus:x,onClick:x},s,{className:(0,o.Z)("tabs__item",c,null==s?void 0:s.className,{"tabs__item--active":C===n})}),t??n)}))),t?(0,i.cloneElement)(y.filter((e=>e.props.value===C))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},y.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==C})))))}function m(e){const n=(0,s.Z)();return i.createElement(u,(0,a.Z)({key:String(n)},e))}},49962:(e,n,t)=>{t.d(n,{Z:()=>a});const a='package org.iota.client.example;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.iota.client.*;\nimport org.iota.client.local.*;\n\npublic class ExampleApp {\n\n    protected static final String MAINNET = "https://chrysalis-nodes.iota.cafe";\n\n    // Faucet: https://faucet.chrysalis-devnet.iota.cafe/\n    // Explorer: https://explorer.iota.org/devnet\n    protected static final String TESTNET = "https://api.lb-0.h.chrysalis-devnet.iota.cafe";\n    protected static final String TESTNET_LB = "api.lb-0.h.chrysalis-devnet.iota.cafe";\n\n    protected static final String NODE = TESTNET;\n\n    static {\n        NativeAPI.verifyLink();\n    }\n\n    public static void main(String[] args) {\n\n        try {\n            new ExampleApp();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ExampleApp() {\n\n    }\n\n    private static Client node() {\n        Client iota = Client.Builder().withNode(NODE) // Insert your node URL here\n                // .withNodeAuth("https://somechrysalisiotanode.com", "jwt_or_null",\n                // "name_or_null", "password_or_null") //\n                // Optional authentication\n                .finish();\n        return iota;\n    }\n\n    public static void nodeInfo() {\n        try {\n            Client iota = node();\n\n            System.out.println("Node healthy: " + iota.getHealth());\n\n            NodeInfoWrapper info = iota.getInfo();\n            System.out.println("Node url: " + info.url());\n            System.out.println("Node Info: " + info.nodeInfo());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateSeed() {\n        try {\n            SecretKey secret_key = SecretKey.generate();\n            System.out.println(RustHex.encode(secret_key.toBytes()));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateAddresses() {\n        try {\n            Client iota = node();\n\n            String seed = RustHex.encode("NONSECURE_USE_OF_DEVELOPMENT_SEED_1");\n            String[] addresses = GetAddressesBuilder.from(seed).withClient(iota).withRange(0, 10).finish();\n            System.out.println(Arrays.toString(addresses));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getBalance() {\n        try {\n            Client iota = node();\n\n            String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n            long seed_balance = iota.getBalance(seed).finish();\n            System.out.println("Account balance: " + seed_balance);\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            BalanceAddressResponse response = iota.getAddress().balance(address);\n            System.out.println("The balance of " + address + " is " + response.balance());\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getOutputs() {\n        try {\n            Client iota = node();\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void simpleMessage() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            System.out.println(\n                    "Empty message sent: https://explorer.iota.org/mainnet/message/" + message.id().toString());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getMessageMetadata() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            MessageMetadata metadata = iota.getMessage().metadata(message.id());\n\n            System.out.println("Message metadata: " + metadata);\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getDataMessage() {\n        Client iota = node();\n\n        Message message = iota.message().withIndexString("Hello").withDataString("Tangle").finish();\n\n        System.out.println("Message sent https://explorer.iota.org/devnet/message/" + message.id());\n\n        MessageId[] fetched_message_ids = iota.getMessage().indexString("Hello");\n        System.out.println("Messages with Hello index: " + Arrays.toString(fetched_message_ids));\n    }\n\n    public static void transaction() {\n        Client iota = node();\n\n        String seed_1 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        Message message = iota\n            .message()\n            .withSeed(seed_1)\n            // Insert the output address and amount to spent. The amount cannot be zero.\n            .withOutput(\n                // We generate an address from our seed so that we send the funds to ourselves\n                        iota.getAddresses(seed_1).withRange(0, 1).finish()[0], 1000000\n            ).finish();\n\n        System.out.println("Transaction sent: https://explorer.iota.org/devnet/message/" +  message.id());\n    }\n\n    public static void mqtt() {\n        Client iota = node();\n\n        MqttListener listener = new MqttListener() {\n            @Override\n            public void onEvent(TopicEvent event) {\n                System.out.println(event);\n            }\n        };\n\n        // TODO: Make listeners with the Sync trait\n        // iota.subscriber().withTopic(Topic.from("messages")).subscribe(listener);\n    }\n\n    public static void consolidate() {\n        Client iota = node();\n\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        // Here all funds will be send to the address with the lowest index in the range\n        String address = Util.consolidateFunds(iota, seed, 0, 0, 150);\n\n        System.out.println("Funds consolidated to" + address);\n    }\n\n    public static void createMaxDust(){\n        Client iota = node();\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String seed_2 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_2";\n\n        String[] new_addresses = iota.getAddresses(seed_2).withRange(0, 1).finish();\n\n        Message dustAllowanceMessage = iota\n            .message()\n            .withSeed(seed)\n            .withDustAllowanceOutput(new_addresses[0], 10_000_000)\n            .finish();\n\n        MessageWrap[] msgs = iota.retryUntilIncluded(dustAllowanceMessage.id(), -1, -1);\n\n        // Split funds to own addresses\n        String[] addresses = iota\n            .getAddresses(seed)\n            // We start from index 1 so we can send remaining balance to the address with index 0\n            .withRange(1, 101)\n            .finish();\n\n        ClientMessageBuilder message_builder = iota.message().withSeed(seed);\n        for (String address : addresses) {\n            // Make sure to re-set the builder as the instance is a clone of the old one due to JNI limits\n            message_builder = message_builder.withOutput(address, 1_000_001);\n        }\n        Message message = message_builder.finish();\n\n        System.out.println(\n            "First transaction sent: https://explorer.iota.org/devnet/message/" + message.id()\n        );\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n\n        // At this point we have 100 Mi on 100 addresses and we will just send it to the final address\n        // We use the outputs directly so we don\'t double spend them\n        \n        List<UtxoInput> initial_outputs = new ArrayList<>();\n        Optional<MessagePayload> payload = message.payload();\n        if (payload.isPresent() && payload.get().payloadType().equals(MessagePayloadType.TRANSACTION)) {\n            TransactionPayload tx = payload.get().asTransaction();\n            RegularEssence essence = tx.essence().asRegular();\n            Output[] outputs = essence.outputs();\n            for (int index = 0; index < outputs.length; index++) {\n                Output output = outputs[index];\n                if (output.asSignatureLockedSingleOutput().amount() == 1_000_001) {\n                    initial_outputs.add(UtxoInput.from(tx.id(), index));\n                } \n            }\n        }\n\n        String[] first_address_old_seed = iota.getAddresses(seed).withRange(0, 1).finish();\n        List<MessageId> sent_messages = new ArrayList<>();\n        for (UtxoInput input : initial_outputs) {\n            MessageId message_id = iota\n                .message()\n                    .withSeed(seed).withInput(input).withInputRange(1, 101).withOutput(new_addresses[0], 1)\n                // send remaining iotas back\n                    .withOutput(first_address_old_seed[0], 1_000_000)\n                .finish()\n                    .id();\n            System.out.printf("Transaction %i sent: https://explorer.iota.org/devnet/message/%s" + input.index(),\n                    message_id\n            );\n            sent_messages.add(message_id);\n        }\n        // only check last message, if this gets confirmed all other messages should also be confirmed\n        msgs = iota.retryUntilIncluded(sent_messages.get(sent_messages.size() - 1), -1, -1);\n        // Send all funds back to first address\n        long total_balance = iota.getBalance(seed).finish();\n\n        System.out.println("Total balance: " + total_balance);\n\n        message = iota\n            .message()\n            .withSeed(seed)\n            .withOutput(first_address_old_seed[0], total_balance)\n            .finish();\n\n        System.out.println("Final tx sent: https://explorer.iota.org/devnet/message/" + message.id());\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n    }\n\n    public static void customPayload() {\n        // Create a client instance\n        Client iota = node();\n\n        IndexationPayload indexation_payload = IndexationPayload.fromStrings("Your Index", "Your Data");\n\n        Message message = iota.message().finishIndex(indexation_payload);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n\n    public static void offlineExample() {\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String toAddress = "atoi1qruzprxum2934lr3p77t96pzlecxv8pjzvtjrzdcgh2f5exa22n6gek0qdq";\n        long amount = 1_000_000;\n\n        Offline offlineExample = new Offline(NODE, seed);\n        String[] inputAddresses = offlineExample.generateAddresses();\n        String preparedData = offlineExample.prepareTransaction(inputAddresses, toAddress, amount);\n        System.out.println("Prepared data: " + preparedData);\n        String signedData = offlineExample.signTransaction(preparedData);\n        System.out.println("Signed data: " + signedData);\n\n        Message message = offlineExample.sendMessage(signedData);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n}\n'}}]);