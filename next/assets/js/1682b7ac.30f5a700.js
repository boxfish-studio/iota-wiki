"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[51393],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(n),h=r,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},93419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={description:"Smart contracts can be invoked through their entry points, from outside via a request, or from inside via a call.",image:"/img/logo/WASP_logo_dark.png",keywords:["smart contracts","requests","on-ledger","off-ledger","calls","invocation","explanation"]},s="Calling a Smart Contract",i={unversionedId:"guide/core_concepts/invocation",id:"guide/core_concepts/invocation",title:"Calling a Smart Contract",description:"Smart contracts can be invoked through their entry points, from outside via a request, or from inside via a call.",source:"@site/next/external/wasp/documentation/docs/guide/core_concepts/invocation.md",sourceDirName:"guide/core_concepts",slug:"/guide/core_concepts/invocation",permalink:"/next/smart-contracts/guide/core_concepts/invocation",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/develop/documentation/next/external/wasp/documentation/docs/guide/core_concepts/invocation.md",tags:[],version:"current",frontMatter:{description:"Smart contracts can be invoked through their entry points, from outside via a request, or from inside via a call.",image:"/img/logo/WASP_logo_dark.png",keywords:["smart contracts","requests","on-ledger","off-ledger","calls","invocation","explanation"]},sidebar:"tutorialSidebar",previous:{title:"Anatomy of a Smart Contract",permalink:"/next/smart-contracts/guide/core_concepts/smart-contract-anatomy"},next:{title:"Sandbox Interface",permalink:"/next/smart-contracts/guide/core_concepts/sandbox"}},c={},l=[{value:"Entry Points",id:"entry-points",level:2},{value:"Synchronous Composability",id:"synchronous-composability",level:3},{value:"Requests",id:"requests",level:2},{value:"Asynchronous Composability",id:"asynchronous-composability",level:3},{value:"On-Ledger Requests",id:"on-ledger-requests",level:3},{value:"Off-Ledger Requests",id:"off-ledger-requests",level:3},{value:"Gas",id:"gas",level:2},{value:"Allowance",id:"allowance",level:2}],u={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"calling-a-smart-contract"},"Calling a Smart Contract"),(0,r.kt)("h2",{id:"entry-points"},"Entry Points"),(0,r.kt)("p",null,"Like any other computer program, a smart contract will lie dormant until someone or something instructs it to activate.\nIn the case of smart contracts, the most common way to activate them is to call one of\ntheir ",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/core_concepts/smart-contract-anatomy#entry-points"},"entry points"),". It is the same as calling a program's function. It will\ntake a set of instructions of the smart contract and execute it over the current chain's state. ",(0,r.kt)("em",{parentName:"p"},"View entry points")," can\nonly read the state, while ",(0,r.kt)("em",{parentName:"p"},"full entry points")," can read and write to it."),(0,r.kt)("p",null,"To invoke a smart contract from outside the chain, the ",(0,r.kt)("em",{parentName:"p"},"sender")," (some entity that needs to be identified by a\nprivate/public key pair) has to wrap the call to the entry point into a ",(0,r.kt)("em",{parentName:"p"},"request"),".\nThe request has to be cryptographically signed and submitted to the ",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/core_concepts/consensus"},"consensus")," procedure to let the\nchain's committee evaluate it and engrave the outcome of its execution into a new state update."),(0,r.kt)("p",null,"Upon receiving a request, the committee will execute the wrapped call fully or reject the request with all its potential\nchanges, never modifying the state halfway. This means that every single request is an atomic operation."),(0,r.kt)("h3",{id:"synchronous-composability"},"Synchronous Composability"),(0,r.kt)("p",null,"After being invoked by a request, the smart contract code is allowed to invoke entry points of other smart contracts on\nthe same chain. This means it can ",(0,r.kt)("em",{parentName:"p"},"call")," other smart contracts."),(0,r.kt)("p",null,"Smart contract calls are deterministic and synchronous, meaning they always produce the same result and execute all\ninstructions immediately after another.\nIf a smart contract calls another smart contract, the resulting set of instructions is also deterministic and\nsynchronous. This means that for a request, it makes no difference if a smart contract's entry point contains the whole\nset of instructions or if it is composed by multiple calls to different smart contracts of the chain."),(0,r.kt)("p",null,"Being able to combine smart contracts in this way is called ",(0,r.kt)("em",{parentName:"p"},"synchronous composability"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"requests"},"Requests"),(0,r.kt)("p",null,"A request contains a call to a smart contract and a signature of the sender. The sender also owns the assets and funds\nprocessed within the request.\nUnlike calls between smart contracts, requests are not executed immediately.\nInstead, they must wait until the chain's validator nodes include them in a request batch.\nThis means that requests have a delay and are executed in an unpredictable order."),(0,r.kt)("h3",{id:"asynchronous-composability"},"Asynchronous Composability"),(0,r.kt)("p",null,"Requests are not sent by humans exclusively. Smart contracts can also create requests.\nFor example, a user can send a request to a smart contract that, in turn, sends a request to a decentralized third-party\nexchange which would will the user's funds from one currency to another and send them back through another request."),(0,r.kt)("p",null,"This is called ",(0,r.kt)("em",{parentName:"p"},"asynchronous composability"),"."),(0,r.kt)("h3",{id:"on-ledger-requests"},"On-Ledger Requests"),(0,r.kt)("p",null,"An on-ledger request is a Layer 1 transaction that validator nodes retrieve from the Tangle. The Tangle acts as an\narbiter between users and chains and guarantees that the transaction is valid, making it the only way to transfer assets\nto a chain or between chains. However, it is the slowest way to invoke a smart contract."),(0,r.kt)("h3",{id:"off-ledger-requests"},"Off-Ledger Requests"),(0,r.kt)("p",null,"If all necessary assets are in the chain already, it is possible to send a request directly to that chain's validator\nnodes.\nThis way, you don\u2019t have to wait for the Tangle to process the message, significantly reducing the overall confirmation\ntime.\nDue to the shorter delay, off-ledger requests are preferred over on-ledger requests unless you need to move assets\nbetween chains or Layer 1 accounts."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"gas"},"Gas"),(0,r.kt)("p",null,'Gas expresses the "cost" of running a request in a chain. Each operation (arithmetics, write to disk, dispatch events,\netc.) has an associated gas cost.'),(0,r.kt)("p",null,"For users to specify how much they're willing to pay for a request, they need to specify a ",(0,r.kt)("inlineCode",{parentName:"p"},"GasBudget"),' in the request.\nThis gas budget is the "maximum operations that this request can execute" and will be charged as a fee based on the\nchain\'s current ',(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/core_concepts/core_contracts/governance#fee-policy"},"fee policy"),"."),(0,r.kt)("p",null,"The funds to cover the gas used will be charged directly from the user's on-chain account."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"allowance"},"Allowance"),(0,r.kt)("p",null,"Any funds sent to the chain via on-ledger requests are credited to the sender's account."),(0,r.kt)("p",null,"For contracts to use funds owned by the ",(0,r.kt)("em",{parentName:"p"},"caller"),", the ",(0,r.kt)("em",{parentName:"p"},"caller")," must specify an ",(0,r.kt)("inlineCode",{parentName:"p"},"Allowance")," in the request. Contracts can\nthen claim any of the allowed funds using the sandbox ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferAllowedFunds")," function."),(0,r.kt)("p",null,"The Allowance properly looks like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"{\n  FungibleTokens: {\n    BaseToken: uint64\n    NativeTokens: [{TokenID, uint256}, ...]\n  }\n  NFTs: [NFTID,...]\n}\n")))}d.isMDXComponent=!0}}]);