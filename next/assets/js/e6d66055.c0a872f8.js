"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[4168],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),d=o,h=p["".concat(l,".").concat(d)]||p[d]||m[d]||r;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},51877:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>m});var a=n(87462),o=(n(67294),n(3905)),r=n(34259),s=n(18679);const i={keywords:["function descriptor","return values","request","post","smart contract chain","Asynchronous function"],description:"Asynchronous function calls between smart contracts are posted as requests on the Tangle. They allow you to invoke any smart contract function that is not a View on any smart contract chain.",image:"/img/logo/WASP_logo_dark.png"},l="Posting Asynchronous Requests",c={unversionedId:"guide/wasm_vm/post",id:"guide/wasm_vm/post",title:"Posting Asynchronous Requests",description:"Asynchronous function calls between smart contracts are posted as requests on the Tangle. They allow you to invoke any smart contract function that is not a View on any smart contract chain.",source:"@site/next/external/wasp/documentation/docs/guide/wasm_vm/post.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/post",permalink:"/next/smart-contracts/guide/wasm_vm/post",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/develop/documentation/next/external/wasp/documentation/docs/guide/wasm_vm/post.mdx",tags:[],version:"current",frontMatter:{keywords:["function descriptor","return values","request","post","smart contract chain","Asynchronous function"],description:"Asynchronous function calls between smart contracts are posted as requests on the Tangle. They allow you to invoke any smart contract function that is not a View on any smart contract chain.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Calling Functions",permalink:"/next/smart-contracts/guide/wasm_vm/call"},next:{title:"Testing Smart Contracts",permalink:"/next/smart-contracts/guide/wasm_vm/test"}},u={},m=[],p={toc:m};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"posting-asynchronous-requests"},"Posting Asynchronous Requests"),(0,o.kt)("p",null,"Asynchronous function calls between smart contracts are posted as requests on the Tangle.\nThey allow you to invoke any smart contract function that is not a View on any smart\ncontract chain. You will notice that the behavior is very similar to a synchronous\nfunction call, but instead of using the ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"call()"))," method of the ",(0,o.kt)("inlineCode",{parentName:"p"},"func")," member\nin the function descriptor, you will now use the ",(0,o.kt)("inlineCode",{parentName:"p"},"post()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"postToChain()")," methods. The\n",(0,o.kt)("inlineCode",{parentName:"p"},"post()")," method posts the request to the current chain, while ",(0,o.kt)("inlineCode",{parentName:"p"},"postToChain()")," takes the\nchain ID of the desired chain as parameter."),(0,o.kt)("p",null,"In addition to the previously discussed ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"transferBaseTokens()"))," and\n",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"ofContract()"))," methods, you can modify the behavior further by providing a\n",(0,o.kt)("inlineCode",{parentName:"p"},"delay()")," in seconds, which enables delayed execution of the request. This is of\nparticular interest to smart contracts that need a delayed action like betting contracts\nwith a timed betting round, or to create time-lock functionality in a smart contract.\nHere's how that works:"),(0,o.kt)(r.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"eor := ScFuncs.EndOfRound(ctx)\neor.Func.Delay(3600).Post()\n"))),(0,o.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let eor = ScFuncs::end_of_round(ctx);\neor.func.delay(3600).post();\n"))),(0,o.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"let eor = sc.ScFuncs.endOfRound(ctx);\neor.func.delay(3600).post();\n")))),(0,o.kt)("p",null,"Because it is posted as a request on the Tangle, and it is not possible to have a request\nwithout a transfer, ",(0,o.kt)("em",{parentName:"p"},"an asynchronous request always needs to send at least some tokens"),".\nIn fact, there is a minimum amount of tokens to send, because you need to cover the gas\nthat is necessary to run the function call. You can specify the tokens explicitly, in the\nsame way we did previously with ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},"synchronous calls"),", or you can have WasmLib\nspecify a minimum amount of tokens automatically. Any tokens that are not used will end up\nin the caller's account on the chain."),(0,o.kt)("p",null,"So, if you post to a function that expects tokens you just specify the amount of tokens\nrequired, but if you post to a function that does not expect any tokens then you can have\nWasmLib send the minimum amount for you."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Providing a ",(0,o.kt)("inlineCode",{parentName:"strong"},"delay()")," before a ",(0,o.kt)("a",{parentName:"strong",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"call()"))," will result in a panic"),". We do not\nknow the intention of the user until the actual ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"call()"))," or\n",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/post"},(0,o.kt)("inlineCode",{parentName:"a"},"post()"))," is encountered, so we cannot check for this at compile-time unless we\nare willing to accept a lot of extra overhead. It should not really be a problem because\nusing ",(0,o.kt)("inlineCode",{parentName:"p"},"delay()")," is rare and using it with ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/call"},(0,o.kt)("inlineCode",{parentName:"a"},"call()"))," cannot have been the\nintention."),(0,o.kt)("p",null,"The function that posts the request through the function descriptor will immediately\ncontinue execution and does not wait for its completion. Therefore, it is not possible to\ndirectly retrieve the return values from such a call."),(0,o.kt)("p",null,"If you need some return values, you will have to create a mechanism that can do so, for\nexample by providing a callback chain/contract/function combination as part of the input\nparameters of the requested function, so that upon completion that function can\nasynchronously post the results to the indicated function. It will require a certain\ndegree of cooperation between both smart contracts. In the future we will probably be\nlooking at providing a generic mechanism for this."),(0,o.kt)("p",null,"In the next section we will look at how we can use the function descriptors when\n",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/test"},"testing smart contracts with Solo"),"."))}d.isMDXComponent=!0},18679:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(67294),o=n(86010);const r="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r,s),hidden:n},t)}},34259:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(87462),o=n(67294),r=n(86010),s=n(51048),i=n(33609),l=n(1943),c=n(72957);const u="tabList__CuJ",m="tabItem_LNqP";function p(e){var t;const{lazy:n,block:s,defaultValue:p,values:d,groupId:h,className:f}=e,y=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=d??y.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),g=(0,i.l)(v,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const b=null===p?p:p??(null==(t=y.find((e=>e.props.default)))?void 0:t.props.value)??y[0].props.value;if(null!==b&&!v.some((e=>e.value===b)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${b}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:k}=(0,l.U)(),[x,N]=(0,o.useState)(b),T=[],{blockElementScrollPositionUntilNextRender:_}=(0,c.o5)();if(null!=h){const e=w[h];null!=e&&e!==x&&v.some((t=>t.value===e))&&N(e)}const C=e=>{const t=e.currentTarget,n=T.indexOf(t),a=v[n].value;a!==x&&(_(t),N(a),null!=h&&k(h,String(a)))},O=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=T.indexOf(e.currentTarget)+1;n=T[t]??T[0];break}case"ArrowLeft":{const t=T.indexOf(e.currentTarget)-1;n=T[t]??T[T.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,r.Z)("tabs-container",u)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":s},f)},v.map((e=>{let{value:t,label:n,attributes:s}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:e=>T.push(e),onKeyDown:O,onFocus:C,onClick:C},s,{className:(0,r.Z)("tabs__item",m,null==s?void 0:s.className,{"tabs__item--active":x===t})}),n??t)}))),n?(0,o.cloneElement)(y.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},y.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==x})))))}function d(e){const t=(0,s.Z)();return o.createElement(p,(0,a.Z)({key:String(t)},e))}}}]);